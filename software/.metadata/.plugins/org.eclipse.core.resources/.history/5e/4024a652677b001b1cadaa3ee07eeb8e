#include "system.h"
#include "altera_up_avalon_accelerometer_spi.h"
#include "altera_avalon_jtag_uart.h"
#include "altera_avalon_timer_regs.h"
#include "altera_avalon_timer.h"
#include "altera_avalon_pio_regs.h"
#include "sys/alt_irq.h"
#include <stdlib.h>
#include "sys/alt_stdio.h"
#include "alt_types.h"
#include <unistd.h>
#include <stdio.h>

alt_u8 sev_seg(char in);

// Convenient way to get current state
enum dev_state{
		FILT_ON,
		FILT_OFF,
		COEFF_UPDATE
};

alt_u8 dev_state = FILT_OFF;

int main()
{ 
	alt_32 x_read;	// For some reason the driver expects a 32-bit value
	alt_up_accelerometer_spi_dev * acc_dev;
	acc_dev = alt_up_accelerometer_spi_open_dev("/dev/accelerometer_spi");
	if (acc_dev == NULL) { // if return 1, check if the spi ip name is "accelerometer_spi"
		alt_printf("[FATAL] No accelerometer device available\n");
		return 1;
	}

	alt_printf("[INFO] Starting filtering.\n");

  /* Event loop never exits. */
  while (1){
//	  switch (filt_state) {
//			case FILT_OFF:
//				break;
//		}
	  alt_up_accelerometer_spi_read_x_axis(acc_dev, &x_read);
	  alt_8 status = write(1, &x_read, sizeof(x_read));
	  // '1' refers to stdout
	  if (status == -1) {
		  alt_printf("[FATAL] Error in write\n");
		  return 1;
	  }
//	  else if (status < sizeof(x_read)) {
//		  alt_printf("[WARN] Sent %x with size %x\n", x_read, status);
//		  return 1;
//	  }

	  alt_putchar('\n');	// Send a nice newline for Python
	  usleep(2500);	// Don't print so fast!!
  }

  return 0;
}

alt_u8 sev_seg(char in){

}


 /*
  * Todo:
  * - Read accelerometer data
  * - Pass it as bytes over UART
  * - Accept a state that
  */
