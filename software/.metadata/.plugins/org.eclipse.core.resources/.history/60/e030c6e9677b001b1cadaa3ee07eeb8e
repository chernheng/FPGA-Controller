#include "system.h"
#include "altera_up_avalon_accelerometer_spi.h"
#include "altera_avalon_jtag_uart.h"
#include "altera_avalon_timer_regs.h"
#include "altera_avalon_timer.h"
#include "altera_avalon_pio_regs.h"
#include "sys/alt_irq.h"
#include <stdlib.h>
#include "sys/alt_stdio.h"
#include "alt_types.h"
#include <unistd.h>
#include <stdio.h>

alt_u8 sev_seg(char in);
alt_u8 sev_seg(int num);

// Convenient way to get current state
enum dev_state{
		FILT_ON,
		FILT_OFF,
		COEFF_UPDATE
};

alt_u8 dev_state = FILT_OFF;

int main()
{ 
	alt_32 x_read;	// For some reason the driver expects a 32-bit value
	alt_up_accelerometer_spi_dev * acc_dev;
	acc_dev = alt_up_accelerometer_spi_open_dev("/dev/accelerometer_spi");
	if (acc_dev == NULL) { // if return 1, check if the spi ip name is "accelerometer_spi"
		alt_printf("[FATAL] No accelerometer device available\n");
		return 1;
	}

	alt_printf("[INFO] Starting filtering.\n");

  /* Event loop never exits. */
  while (1){
//	  switch (filt_state) {
//			case FILT_OFF:
//				break;
//		}
	  alt_up_accelerometer_spi_read_x_axis(acc_dev, &x_read);
	  alt_8 status = write(1, &x_read, sizeof(x_read));
	  // '1' refers to stdout
	  if (status == -1) {
		  alt_printf("[FATAL] Error in write\n");
		  return 1;
	  }
	  IOWR(HEX0_BASE, 0, sev_seg(status));
//	  else if (status < sizeof(x_read)) {
//		  alt_printf("[WARN] Sent %x with size %x\n", x_read, status);
//		  return 1;
//	  }

	  alt_putchar('\n');	// Send a nice newline for Python
	  usleep(2500);	// Don't print so fast!!
  }

  return 0;
}

alt_u8 sev_seg(int num){
	switch(num){
		case 0:
			return 0b1000000;
		case 1:
			return 0b1111001;
		case 2:
			return 0b0100100;
		case 3:
			return 0b0110000;
		case 4:
			return 0b0011001;
		case 5:
			return 0b0010010;
		case 6:
			return 0b0000010;
		case 7:
			return 0b1111000;
		case 8:
			return 0b0000000;
		case 9:
			return 0b0010000;
		case 10:
			return 0b0001000;	// 0xA
		case 11:
			return 0b0000011;	// 0xB
		case 12:
			return 0b1000110;	// 0xC
		case 13:
			return 0b0100001;	// 0xD
		case 14:
			return 0b0000110;	// 0xE
		case 15:
			return 0b0001110;	// 0xF
		default:
			return 0b0010000;	// lowercase 'e' error
	}
}

 /*
  * Todo:
  * - Read accelerometer data
  * - Pass it as bytes over UART
  * - Accept a state that
  */
